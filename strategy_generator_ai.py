"""
Objective-Aware Strategy Generator AI
The CORE BRAIN that generates completely different trading strategies based on objectives
Same indicators + Different objectives = Totally different trading logic!
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Tuple, Any
import random
from datetime import datetime
import warnings
warnings.filterwarnings('ignore')

# Import your previous components
from comprehensive_indicator_library import ComprehensiveIndicatorLibrary
from performance_objectives import ObjectiveManager, PerformanceObjective

class TradingStrategy:
    """
    Container for a complete trading strategy generated by AI
    Includes all logic for entries, exits, position sizing, and risk management
    """
    
    def __init__(self, strategy_id: str, objective_name: str, 
                 strategy_config: Dict, fitness_score: float = 0.0):
        self.strategy_id = strategy_id
        self.objective_name = objective_name
        self.config = strategy_config
        self.fitness_score = fitness_score
        self.trades = []
        self.equity_curve = pd.Series()
        self.performance_metrics = {}
        
    def execute_on_data(self, df: pd.DataFrame, indicator_lib: ComprehensiveIndicatorLibrary) -> Dict:
        """Execute this strategy on historical data"""
        # Calculate all required indicators
        indicators_needed = self.config['indicators']
        indicator_data = {}
        
        for indicator_name in indicators_needed:
            params = self.config.get('indicator_params', {}).get(indicator_name, {})
            indicator_data[indicator_name] = indicator_lib.calculate_indicator(
                indicator_name, df, **params
            )
        
        # Generate trading signals
        signals = self._generate_signals(df, indicator_data)
        
        # Execute trades based on signals
        trades, equity_curve = self._execute_trades(df, signals)
        
        # Store results
        self.trades = trades
        self.equity_curve = equity_curve
        self.performance_metrics = self._calculate_performance_metrics()
        
        return {
            'trades': trades,
            'equity_curve': equity_curve,
            'metrics': self.performance_metrics,
            'signals': signals
        }
    
    def _generate_signals(self, df: pd.DataFrame, indicators: Dict) -> pd.Series:
        """Generate buy/sell signals based on strategy logic"""
        signals = pd.Series(0, index=df.index)  # 0=hold, 1=buy, -1=sell
        
        entry_logic = self.config['entry_logic']
        exit_logic = self.config['exit_logic']
        
        for i in range(len(df)):
            if i < 50:  # Need enough data for indicators
                continue
                
            # Check entry conditions
            if self._evaluate_entry_conditions(i, df, indicators, entry_logic):
                signals.iloc[i] = 1
            
            # Check exit conditions (if in position)
            elif self._evaluate_exit_conditions(i, df, indicators, exit_logic):
                signals.iloc[i] = -1
        
        return signals
    
    def _evaluate_entry_conditions(self, i: int, df: pd.DataFrame, 
                                 indicators: Dict, entry_logic: Dict) -> bool:
        """Evaluate if entry conditions are met"""
        try:
            conditions_met = 0
            total_conditions = len(entry_logic['conditions'])
            
            for condition in entry_logic['conditions']:
                if self._check_condition(i, df, indicators, condition):
                    conditions_met += 1
            
            # Check if enough conditions are met
            required_ratio = entry_logic.get('confirmation_ratio', 0.8)
            return (conditions_met / total_conditions) >= required_ratio
            
        except Exception:
            return False
    
    def _evaluate_exit_conditions(self, i: int, df: pd.DataFrame, 
                                indicators: Dict, exit_logic: Dict) -> bool:
        """Evaluate if exit conditions are met"""
        try:
            for condition in exit_logic['conditions']:
                if self._check_condition(i, df, indicators, condition):
                    return True
            return False
        except Exception:
            return False
    
    def _check_condition(self, i: int, df: pd.DataFrame, indicators: Dict, condition: Dict) -> bool:
        """Check individual condition"""
        try:
            indicator_name = condition['indicator']
            operator = condition['operator']
            threshold = condition['threshold']
            
            if indicator_name not in indicators:
                return False
            
            current_value = indicators[indicator_name].iloc[i]
            
            if pd.isna(current_value):
                return False
            
            # Apply operator
            if operator == '>':
                return current_value > threshold
            elif operator == '<':
                return current_value < threshold
            elif operator == '>=':
                return current_value >= threshold
            elif operator == '<=':
                return current_value <= threshold
            elif operator == 'between':
                return threshold[0] <= current_value <= threshold[1]
            elif operator == 'crossover':
                # Check if indicator crossed above threshold
                if i > 0:
                    prev_value = indicators[indicator_name].iloc[i-1]
                    return prev_value <= threshold < current_value
                return False
            elif operator == 'crossunder':
                # Check if indicator crossed below threshold
                if i > 0:
                    prev_value = indicators[indicator_name].iloc[i-1]
                    return prev_value >= threshold > current_value
                return False
            
            return False
            
        except Exception:
            return False
    
    def _execute_trades(self, df: pd.DataFrame, signals: pd.Series) -> Tuple[List[Dict], pd.Series]:
        """Execute trades based on signals"""
        trades = []
        equity = [10000]  # Starting capital
        position = None
        entry_price = 0
        entry_date = None
        
        position_size_config = self.config.get('position_sizing', {'method': 'fixed', 'size': 0.1})
        
        for i in range(1, len(df)):
            current_equity = equity[-1]
            
            # Entry signal
            if signals.iloc[i] == 1 and position is None:
                entry_price = df['Close'].iloc[i]
                entry_date = df.index[i]
                position = 'long'
                
            # Exit signal
            elif signals.iloc[i] == -1 and position is not None:
                exit_price = df['Close'].iloc[i]
                exit_date = df.index[i]
                
                # Calculate trade result
                pnl_pct = (exit_price - entry_price) / entry_price
                position_size = self._calculate_position_size(current_equity, position_size_config)
                pnl_dollars = current_equity * position_size * pnl_pct
                
                # Record trade
                trade = {
                    'entry_date': entry_date,
                    'exit_date': exit_date,
                    'entry_price': entry_price,
                    'exit_price': exit_price,
                    'pnl_pct': pnl_pct * 100,
                    'pnl_dollars': pnl_dollars,
                    'position_size': position_size,
                    'duration': (exit_date - entry_date).days
                }
                trades.append(trade)
                
                # Update equity
                new_equity = current_equity + pnl_dollars
                equity.append(new_equity)
                position = None
            else:
                equity.append(current_equity)
        
        return trades, pd.Series(equity, index=df.index[:len(equity)])
    
    def _calculate_position_size(self, equity: float, config: Dict) -> float:
        """Calculate position size based on configuration"""
        method = config.get('method', 'fixed')
        
        if method == 'fixed':
            return config.get('size', 0.1)
        elif method == 'volatility_adjusted':
            # Simple volatility adjustment (would use ATR in real implementation)
            base_size = config.get('base_size', 0.1)
            volatility_factor = config.get('volatility_factor', 1.0)
            return base_size / volatility_factor
        else:
            return 0.1
    
    def _calculate_performance_metrics(self) -> Dict:
        """Calculate performance metrics for this strategy"""
        if not self.trades or len(self.equity_curve) < 2:
            return {}
        
        try:
            # Basic metrics
            total_trades = len(self.trades)
            winning_trades = sum(1 for t in self.trades if t['pnl_pct'] > 0)
            win_rate = winning_trades / total_trades if total_trades > 0 else 0
            
            # Return metrics
            total_return = (self.equity_curve.iloc[-1] / self.equity_curve.iloc[0] - 1) * 100
            
            # Drawdown
            peak = self.equity_curve.expanding().max()
            drawdown = (self.equity_curve - peak) / peak
            max_drawdown = abs(drawdown.min()) * 100
            
            # Risk metrics
            daily_returns = self.equity_curve.pct_change().dropna()
            volatility = daily_returns.std() * np.sqrt(252) * 100 if len(daily_returns) > 1 else 0
            
            return {
                'total_trades': total_trades,
                'win_rate': win_rate,
                'total_return_pct': total_return,
                'max_drawdown_pct': max_drawdown,
                'volatility_pct': volatility,
                'avg_trade_pct': np.mean([t['pnl_pct'] for t in self.trades]) if self.trades else 0,
                'avg_duration_days': np.mean([t['duration'] for t in self.trades]) if self.trades else 0
            }
        except Exception:
            return {}

class ObjectiveAwareStrategyGenerator:
    """
    The CORE AI BRAIN that generates completely different strategies based on objectives
    This is where the magic happens - same indicators, totally different logic!
    """
    
    def __init__(self, indicator_library: ComprehensiveIndicatorLibrary,
                 objective_manager: ObjectiveManager):
        self.indicator_lib = indicator_library
        self.objective_manager = objective_manager
        self.strategy_templates = self._create_strategy_templates()
        self.generated_strategies = {}
        
        print("ðŸ§  Objective-Aware Strategy Generator AI initialized")
        print(f"ðŸ”§ Ready to generate infinite strategies from {len(self.indicator_lib.indicators_catalog)} indicators")
    
    def _create_strategy_templates(self) -> Dict:
        """Create strategy templates for different objectives"""
        return {
            'linear_equity': {
                'focus': 'consistency',
                'preferred_indicators': ['bb_position', 'rsi', 'market_efficiency', 'stochastic'],
                'entry_style': 'ultra_selective',
                'exit_style': 'quick_profits',
                'risk_management': 'tight'
            },
            'max_roi': {
                'focus': 'returns',
                'preferred_indicators': ['tsf', 'linreg_slope', 'bb_position', 'volume_profile'],
                'entry_style': 'trend_following',
                'exit_style': 'let_winners_run',
                'risk_management': 'wide'
            },
            'min_drawdown': {
                'focus': 'preservation',
                'preferred_indicators': ['bb_position', 'support_resistance', 'rsi', 'atr'],
                'entry_style': 'extremely_selective',
                'exit_style': 'immediate_profits',
                'risk_management': 'ultra_tight'
            },
            'high_winrate': {
                'focus': 'accuracy',
                'preferred_indicators': ['bb_position', 'rsi', 'stochastic', 'market_efficiency'],
                'entry_style': 'mean_reversion',
                'exit_style': 'quick_profits',
                'risk_management': 'moderate'
            },
            'sharpe_ratio': {
                'focus': 'risk_adjusted',
                'preferred_indicators': ['bb_position', 'atr', 'volatility_ratio', 'rsi'],
                'entry_style': 'volatility_aware',
                'exit_style': 'risk_adjusted',
                'risk_management': 'dynamic'
            }
        }
    
    def generate_strategy_for_objective(self, objective_name: str, 
                                      complexity_level: str = 'moderate') -> TradingStrategy:
        """
        Generate a completely new strategy tailored to the specific objective
        This is the CORE GENERATIVE FUNCTION!
        """
        print(f"\nðŸŽ¯ Generating strategy for objective: {objective_name.upper()}")
        
        # Get objective and its preferences
        objective = self.objective_manager.get_objective(objective_name)
        objective_prefs = objective.get_strategy_preferences()
        template = self.strategy_templates.get(objective_name, self.strategy_templates['linear_equity'])
        
        # Generate unique strategy ID
        strategy_id = f"{objective_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        # AI GENERATES THE STRATEGY LOGIC BASED ON OBJECTIVE
        strategy_config = self._generate_adaptive_logic(objective_prefs, template, complexity_level)
        
        # Create strategy object
        strategy = TradingStrategy(strategy_id, objective_name, strategy_config)
        
        print(f"âœ… Generated strategy '{strategy_id}' with {len(strategy_config['indicators'])} indicators")
        print(f"ðŸ“Š Entry conditions: {len(strategy_config['entry_logic']['conditions'])}")
        print(f"ðŸŽ¯ Exit conditions: {len(strategy_config['exit_logic']['conditions'])}")
        
        return strategy
    
    def _generate_adaptive_logic(self, objective_prefs: Dict, template: Dict, 
                               complexity_level: str) -> Dict:
        """
        THE CORE AI LOGIC GENERATOR
        Creates completely different trading logic based on objectives
        """
        
        # Select indicators based on objective preferences
        preferred_indicators = template['preferred_indicators']
        
        # Add some randomness for variety while staying objective-focused
        available_indicators = list(self.indicator_lib.indicators_catalog.keys())
        additional_indicators = [ind for ind in available_indicators 
                               if ind not in preferred_indicators]
        
        # Determine number of indicators based on complexity
        complexity_map = {'simple': 3, 'moderate': 5, 'complex': 7}
        total_indicators = complexity_map.get(complexity_level, 5)
        
        # Select final indicator set
        selected_indicators = preferred_indicators[:total_indicators//2]
        if len(selected_indicators) < total_indicators:
            random.shuffle(additional_indicators)
            selected_indicators.extend(additional_indicators[:total_indicators - len(selected_indicators)])
        
        # Generate entry logic based on objective
        entry_logic = self._generate_entry_logic(objective_prefs, template, selected_indicators)
        
        # Generate exit logic based on objective
        exit_logic = self._generate_exit_logic(objective_prefs, template, selected_indicators)
        
        # Generate position sizing based on objective
        position_sizing = self._generate_position_sizing(objective_prefs)
        
        return {
            'indicators': selected_indicators,
            'entry_logic': entry_logic,
            'exit_logic': exit_logic,
            'position_sizing': position_sizing,
            'objective_focus': template['focus'],
            'indicator_params': self._generate_indicator_params(selected_indicators)
        }
    
    def _generate_entry_logic(self, objective_prefs: Dict, template: Dict, 
                            indicators: List[str]) -> Dict:
        """Generate entry conditions based on objective preferences"""
        
        conditions = []
        entry_style = template['entry_style']
        
        # OBJECTIVE-SPECIFIC LOGIC GENERATION
        if entry_style == 'ultra_selective':
            # For linear equity - need MANY confirmations
            confirmation_ratio = 0.9  # 90% of conditions must be met
            
            # Mean-reversion focused entries
            if 'bb_position' in indicators:
                conditions.append({
                    'indicator': 'bb_position',
                    'operator': '<',
                    'threshold': 25,  # Oversold
                    'weight': 2  # High importance
                })
            
            if 'rsi' in indicators:
                conditions.append({
                    'indicator': 'rsi',
                    'operator': '<',
                    'threshold': 35,  # Oversold
                    'weight': 2
                })
            
            if 'market_efficiency' in indicators:
                conditions.append({
                    'indicator': 'market_efficiency',
                    'operator': '>',
                    'threshold': 70,  # High efficiency (not choppy)
                    'weight': 1
                })
        
        elif entry_style == 'trend_following':
            # For max ROI - trend-following entries
            confirmation_ratio = 0.6  # Only 60% need to agree (more opportunities)
            
            if 'tsf' in indicators:
                conditions.append({
                    'indicator': 'tsf',
                    'operator': 'crossover',
                    'threshold': 0,  # Price crossing above forecast
                    'weight': 3
                })
            
            if 'linreg_slope' in indicators:
                conditions.append({
                    'indicator': 'linreg_slope',
                    'operator': '>',
                    'threshold': 0.1,  # Positive trend
                    'weight': 2
                })
            
            if 'volume_profile' in indicators:
                conditions.append({
                    'indicator': 'volume_profile',
                    'operator': '>=',
                    'threshold': 1,  # High volume confirmation
                    'weight': 1
                })
        
        elif entry_style == 'extremely_selective':
            # For min drawdown - ultra-conservative
            confirmation_ratio = 0.95  # 95% must agree
            
            if 'bb_position' in indicators:
                conditions.append({
                    'indicator': 'bb_position',
                    'operator': 'between',
                    'threshold': [20, 30],  # Very specific range
                    'weight': 3
                })
            
            if 'support_resistance' in indicators:
                conditions.append({
                    'indicator': 'support_resistance',
                    'operator': '>=',
                    'threshold': 1,  # Near support
                    'weight': 2
                })
        
        elif entry_style == 'mean_reversion':
            # For high win rate - mean reversion focus
            confirmation_ratio = 0.8
            
            if 'bb_position' in indicators:
                conditions.append({
                    'indicator': 'bb_position',
                    'operator': '<',
                    'threshold': 20,  # Oversold
                    'weight': 2
                })
            
            if 'stochastic' in indicators:
                conditions.append({
                    'indicator': 'stochastic',
                    'operator': '<',
                    'threshold': 25,  # Oversold
                    'weight': 2
                })
        
        else:  # volatility_aware for Sharpe ratio
            confirmation_ratio = 0.7
            
            if 'volatility_ratio' in indicators:
                conditions.append({
                    'indicator': 'volatility_ratio',
                    'operator': '<',
                    'threshold': 1.2,  # Not too volatile
                    'weight': 2
                })
        
        # Add additional conditions for other indicators
        self._add_supplementary_conditions(conditions, indicators, entry_style)
        
        return {
            'conditions': conditions,
            'confirmation_ratio': confirmation_ratio,
            'style': entry_style
        }
    
    def _generate_exit_logic(self, objective_prefs: Dict, template: Dict, 
                           indicators: List[str]) -> Dict:
        """Generate exit conditions based on objective preferences"""
        
        conditions = []
        exit_style = template['exit_style']
        
        # OBJECTIVE-SPECIFIC EXIT LOGIC
        if exit_style == 'quick_profits':
            # Take profits quickly for consistent growth
            if 'bb_position' in indicators:
                conditions.append({
                    'indicator': 'bb_position',
                    'operator': '>',
                    'threshold': 60,  # Take profit at 60% of BB range
                    'weight': 2
                })
        
        elif exit_style == 'let_winners_run':
            # Hold for bigger moves
            if 'bb_position' in indicators:
                conditions.append({
                    'indicator': 'bb_position',
                    'operator': '>',
                    'threshold': 85,  # Hold until near upper BB
                    'weight': 2
                })
            
            if 'linreg_slope' in indicators:
                conditions.append({
                    'indicator': 'linreg_slope',
                    'operator': '<',
                    'threshold': 0,  # Exit when trend turns
                    'weight': 1
                })
        
        elif exit_style == 'immediate_profits':
            # Ultra-fast profit taking for drawdown protection
            if 'bb_position' in indicators:
                conditions.append({
                    'indicator': 'bb_position',
                    'operator': '>',
                    'threshold': 55,  # Very quick profit taking
                    'weight': 3
                })
        
        # Always add RSI overbought exit if available
        if 'rsi' in indicators:
            conditions.append({
                'indicator': 'rsi',
                'operator': '>',
                'threshold': 70,  # Overbought exit
                'weight': 1
            })
        
        return {
            'conditions': conditions,
            'style': exit_style
        }
    
    def _add_supplementary_conditions(self, conditions: List[Dict], 
                                    indicators: List[str], entry_style: str):
        """Add additional conditions for unused indicators"""
        
        # Add volume confirmation if available
        if 'volume_profile' in indicators and not any(c['indicator'] == 'volume_profile' for c in conditions):
            conditions.append({
                'indicator': 'volume_profile',
                'operator': '>=',
                'threshold': 1,
                'weight': 1
            })
        
        # Add efficiency filter if available
        if 'market_efficiency' in indicators and not any(c['indicator'] == 'market_efficiency' for c in conditions):
            threshold = 60 if entry_style in ['ultra_selective', 'extremely_selective'] else 40
            conditions.append({
                'indicator': 'market_efficiency',
                'operator': '>',
                'threshold': threshold,
                'weight': 1
            })
    
    def _generate_position_sizing(self, objective_prefs: Dict) -> Dict:
        """Generate position sizing rules based on objective"""
        
        risk_tolerance = objective_prefs.get('risk_tolerance', 'moderate')
        
        if risk_tolerance == 'minimal':
            return {'method': 'fixed', 'size': 0.02}  # 2% per trade
        elif risk_tolerance == 'low':
            return {'method': 'fixed', 'size': 0.05}  # 5% per trade
        elif risk_tolerance == 'moderate':
            return {'method': 'fixed', 'size': 0.10}  # 10% per trade
        elif risk_tolerance == 'high':
            return {'method': 'fixed', 'size': 0.15}  # 15% per trade
        else:
            return {'method': 'volatility_adjusted', 'base_size': 0.10, 'volatility_factor': 1.0}
    
    def _generate_indicator_params(self, indicators: List[str]) -> Dict:
        """Generate parameters for indicators based on strategy needs"""
        params = {}
        
        for indicator in indicators:
            if indicator in self.indicator_lib.indicators_catalog:
                default_params = self.indicator_lib.indicators_catalog[indicator]['params']
                # Could add parameter optimization here
                params[indicator] = default_params.copy()
        
        return params
    
    def generate_multiple_strategies(self, objective_name: str, 
                                   count: int = 5) -> List[TradingStrategy]:
        """Generate multiple different strategies for the same objective"""
        
        strategies = []
        complexity_levels = ['simple', 'moderate', 'complex']
        
        for i in range(count):
            complexity = complexity_levels[i % len(complexity_levels)]
            strategy = self.generate_strategy_for_objective(objective_name, complexity)
            strategy.strategy_id += f"_v{i+1}"
            strategies.append(strategy)
        
        return strategies
    
    def compare_strategies_on_data(self, strategies: List[TradingStrategy], 
                                 df: pd.DataFrame) -> pd.DataFrame:
        """Test multiple strategies on the same data and compare results"""
        
        results = []
        
        for strategy in strategies:
            print(f"ðŸ§ª Testing strategy: {strategy.strategy_id}")
            
            # Execute strategy
            strategy.execute_on_data(df, self.indicator_lib)
            
            # Calculate fitness for its objective
            objective = self.objective_manager.get_objective(strategy.objective_name)
            fitness = objective.calculate_fitness(strategy.trades, strategy.equity_curve)
            strategy.fitness_score = fitness
            
            # Collect results
            metrics = strategy.performance_metrics
            results.append({
                'Strategy ID': strategy.strategy_id,
                'Objective': strategy.objective_name.replace('_', ' ').title(),
                'Fitness Score': f"{fitness:.3f}",
                'Total Return %': f"{metrics.get('total_return_pct', 0):.1f}%",
                'Max Drawdown %': f"{metrics.get('max_drawdown_pct', 0):.1f}%",
                'Win Rate %': f"{metrics.get('win_rate', 0)*100:.1f}%",
                'Total Trades': metrics.get('total_trades', 0),
                'Avg Trade %': f"{metrics.get('avg_trade_pct', 0):.2f}%"
            })
        
        return pd.DataFrame(results)

def demonstrate_objective_aware_ai():
    """Demonstrate the AI generating different strategies for different objectives"""
    print("\nðŸ§  OBJECTIVE-AWARE AI DEMONSTRATION")
    print("=" * 60)
    
    # Initialize components
    indicator_lib = ComprehensiveIndicatorLibrary()
    objective_manager = ObjectiveManager()
    ai_generator = ObjectiveAwareStrategyGenerator(indicator_lib, objective_manager)
    
    # Generate strategies for different objectives
    objectives_to_test = ['linear_equity', 'max_roi', 'min_drawdown', 'high_winrate']
    
    print(f"\nðŸŽ¯ Generating strategies for {len(objectives_to_test)} different objectives:")
    
    strategies = []
    for objective in objectives_to_test:
        strategy = ai_generator.generate_strategy_for_objective(objective)
        strategies.append(strategy)
        print(f"âœ… Generated {objective} strategy")
    
    # Show how different the strategies are
    print(f"\nðŸ“Š STRATEGY COMPARISON - Same Indicators, Different Logic:")
    print("-" * 60)
    
    for strategy in strategies:
        config = strategy.config
        print(f"\n{strategy.objective_name.upper()} Strategy:")
        print(f"  Indicators: {', '.join(config['indicators'][:3])}...")
        print(f"  Entry conditions: {len(config['entry_logic']['conditions'])}")
        print(f"  Confirmation ratio: {config['entry_logic']['confirmation_ratio']:.1%}")
        print(f"  Position size: {config['position_sizing']['size']:.1%}")
        print(f"  Focus: {config['objective_focus']}")

if __name__ == "__main__":
    print("ðŸ§  OBJECTIVE-AWARE STRATEGY GENERATOR AI")
    print("=" * 60)
    print("ðŸŽ¯ Generates completely different strategies based on your objectives!")
    print("ðŸ“Š Same indicators â†’ Infinite strategic possibilities")
    
    # Run demonstration
    demonstrate_objective_aware_ai()
    
    print(f"\nâœ… CORE AI BRAIN COMPLETE!")
    print("ðŸš€ Ready to generate adaptive strategies for any objective!")
    print("\nNext steps:")
    print("- Test on real market data")
    print("- Add strategy evolution/learning")
    print("- Connect to live trading system")
