"""
Objective-Aware Strategy Generator AI - FIXED for nGS data compatibility
The CORE BRAIN that generates completely different trading strategies based on objectives
Same indicators + Different objectives = Totally different trading logic!
FIXED: Better error handling and data format compatibility
"""

import random
import warnings
from datetime import datetime
from typing import Any, Dict, List, Optional, Tuple

import numpy as np
import pandas as pd

warnings.filterwarnings("ignore")

# Import your previous components
from comprehensive_indicator_library import ComprehensiveIndicatorLibrary
from performance_objectives import ObjectiveManager


class TradingStrategy:
    """
    Container for a complete trading strategy generated by AI
    Includes all logic for entries, exits, position sizing, and risk management
    ENHANCED: Better error handling and data compatibility
    """

    def __init__(
        self,
        strategy_id: str,
        objective_name: str,
        strategy_config: Dict[str, Any],
        fitness_score: float = 0.0,
    ) -> None:
        self.strategy_id: str = strategy_id
        self.objective_name: str = objective_name
        self.config: Dict[str, Any] = strategy_config
        self.fitness_score: float = fitness_score
        self.trades: List[Dict[str, Any]] = []  # FIXED: explicit annotation
        self.equity_curve: pd.Series = pd.Series()
        self.performance_metrics: Dict[str, Any] = {}  # FIXED: explicit annotation

    def execute_on_data(
        self, df: pd.DataFrame, indicator_lib: ComprehensiveIndicatorLibrary
    ) -> Dict[str, Any]:
        """
        Execute this strategy on historical data - ENHANCED with error handling
        """
        try:
            print(f" Executing strategy {self.strategy_id} on {len(df)} bars of data")
            position_size_config = self.config.get("position_sizing", {})
            position_size = position_size_config.get(
                "size", 5000
            )  # Default size to $5000
            print(f"DEBUG: Using position size for execution {position_size}")

            # CRITICAL: Ensure data has minimum required length
            if len(df) < 50:
                print(f"  Insufficient data: {len(df)} bars (need min 50)")
                return self._return_empty_results()

            # CRITICAL: Verify data columns
            if not self._validate_data_format(df):
                print(f"  Invalid data format for strategy execution")
                return self._return_empty_results()

            # Calculate all required indicators with robust error handling
            indicators_needed = self.config["indicators"]
            indicator_data: Dict[str, pd.Series] = {}
            successful_indicators: List[str] = []

            print(f" Calculating {len(indicators_needed)} indicators...")

            for indicator_name in indicators_needed:
                try:
                    params = self.config.get("indicator_params", {}).get(
                        indicator_name, {}
                    )
                    print(f"   Calculating {indicator_name}...")

                    # FIXED: Use the enhanced indicator library that handles column standardization
                    indicator_values = indicator_lib.calculate_indicator(
                        indicator_name, df, **params
                    )

                    # Validate indicator results
                    if indicator_values is not None and not indicator_values.empty:
                        valid_count = indicator_values.dropna().shape[0]
                        if valid_count > 10:  # Need at least some valid values
                            indicator_data[indicator_name] = indicator_values
                            successful_indicators.append(indicator_name)
                            print(f"    {indicator_name}: {valid_count} valid values")
                        else:
                            print(
                                f"     {indicator_name}: Too few valid values ({valid_count})"
                            )
                    else:
                        print(f"    {indicator_name}: No data returned")

                except Exception as e:
                    print(f"    {indicator_name}: Error - {str(e)[:60]}...")
                    continue

            if len(successful_indicators) < 2:
                print(
                    f"  Only {len(successful_indicators)} indicators successful - strategy needs more"
                )
                return self._return_empty_results()

            print(f" Successfully calculated {len(successful_indicators)} indicators")

            # Update strategy config to only use successful indicators
            self.config["indicators"] = successful_indicators
            self._update_conditions_for_available_indicators(successful_indicators)

            # Generate trading signals
            print(f" Generating trading signals...")
            signals = self._generate_signals(df, indicator_data)
            signal_count = (signals != 0).sum()
            print(f"   Generated {signal_count} trading signals")

            # Execute trades based on signals
            print(f" Executing trades...")
            trades, equity_curve = self._execute_trades(df, signals)
            print(f"   Completed {len(trades)} trades")

            # Store results
            self.trades = trades
            self.equity_curve = equity_curve
            self.performance_metrics = self._calculate_performance_metrics()

            print(f" Strategy execution complete")

            return {
                "trades": trades,
                "equity_curve": equity_curve,
                "metrics": self.performance_metrics,
                "signals": signals,
                "successful_indicators": successful_indicators,
            }

        except Exception as e:
            print(f" Strategy execution failed: {e}")
            import traceback

            traceback.print_exc()
            return self._return_empty_results()

    def _validate_data_format(self, df: pd.DataFrame) -> bool:
        """Validate that data has required columns"""
        required_cols = ["Close", "High", "Low", "Open"]  # After standardization

        # Check for various column name formats
        available_cols = df.columns.tolist()
        has_close = any(col.lower() in ["close", "Close"] for col in available_cols)
        has_high = any(col.lower() in ["high", "High"] for col in available_cols)
        has_low = any(col.lower() in ["low", "Low"] for col in available_cols)
        has_open = any(col.lower() in ["open", "Open"] for col in available_cols)

        if not (has_close and has_high and has_low and has_open):
            print(f" Missing required columns. Available: {available_cols}")
            return False

        return True

    def _return_empty_results(self) -> Dict[str, Any]:
        """Return empty results when strategy execution fails"""
        return {
            "trades": [],
            "equity_curve": pd.Series([10000]),  # Starting capital
            "metrics": {},
            "signals": pd.Series([0]),
            "successful_indicators": [],
        }

    def _update_conditions_for_available_indicators(
        self, available_indicators: List[str]
    ) -> None:
        """Update entry/exit conditions to only use available indicators"""
        try:
            # Update entry logic
            entry_conditions = []
            for condition in self.config["entry_logic"]["conditions"]:
                if condition["indicator"] in available_indicators:
                    entry_conditions.append(condition)

            if entry_conditions:
                self.config["entry_logic"]["conditions"] = entry_conditions
            else:
                # Fallback: create basic conditions with available indicators
                if "bb_position" in available_indicators:
                    entry_conditions.append(
                        {
                            "indicator": "bb_position",
                            "operator": "<",
                            "threshold": 30,
                            "weight": 1,
                        }
                    )
                if "rsi" in available_indicators:
                    entry_conditions.append(
                        {
                            "indicator": "rsi",
                            "operator": "<",
                            "threshold": 40,
                            "weight": 1,
                        }
                    )
                self.config["entry_logic"]["conditions"] = entry_conditions

            # Update exit logic
            exit_conditions = []
            for condition in self.config["exit_logic"]["conditions"]:
                if condition["indicator"] in available_indicators:
                    exit_conditions.append(condition)

            if exit_conditions:
                self.config["exit_logic"]["conditions"] = exit_conditions
            else:
                # Fallback: create basic exit conditions
                if "bb_position" in available_indicators:
                    exit_conditions.append(
                        {
                            "indicator": "bb_position",
                            "operator": ">",
                            "threshold": 70,
                            "weight": 1,
                        }
                    )
                self.config["exit_logic"]["conditions"] = exit_conditions

        except Exception as e:
            print(f"  Error updating conditions: {e}")

    # File: strategy_generator_ai.py
    # _generate_signals
    def _generate_signals(
        self, df: pd.DataFrame, indicators: Dict[str, pd.Series]
    ) -> pd.Series:
        signals = pd.Series(0, index=df.index)  # Default: Hold (0)
        entry_logic = self.config["entry_logic"]
        exit_logic = self.config["exit_logic"]
        in_position = False
        print(f"Starting signal generation for {df.shape[0]} rows...")  # Debug log

        for i in range(50, len(df)):  # Starting after a warmup period
            try:
                print(
                    f"[Row {i}] Current Price Data: {df.iloc[i].to_dict()}"
                )  # Debug log

                if not in_position:
                    if self._evaluate_entry_conditions(i, df, indicators, entry_logic):
                        signals.iloc[i] = 1
                        in_position = True
                        print(f"[Row {i}] Buy Signal Generated!")  # Debug log
                else:
                    if self._evaluate_exit_conditions(i, df, indicators, exit_logic):
                        signals.iloc[i] = -1
                        in_position = False
                        print(f"[Row {i}] Sell Signal Generated!")  # Debug log
            except Exception as e:
                print(f"[Row {i}] Error during signal evaluation: {e}")  # Debug log

        print(
            f"Signal generation complete. Total Buy Signals: {(signals == 1).sum()}, Total Sell Signals: {(signals == -1).sum()}"
        )  # Summary log
        return signals

    # File: strategy_generator_ai.py
    # _evaluate_entry_conditions
    def _evaluate_entry_conditions(
        self,
        i: int,
        df: pd.DataFrame,
        indicators: Dict[str, pd.Series],
        entry_logic: Dict[str, Any],
    ) -> bool:
        try:
            conditions_met = 0
            total_conditions = len(entry_logic["conditions"])
            required_ratio = entry_logic.get("confirmation_ratio", 0.6)

            print(
                f"  Evaluating entry conditions at row {i}: Total Conditions = {total_conditions}"
            )  # Debug log

            for condition in entry_logic["conditions"]:
                try:
                    if self._check_condition(i, df, indicators, condition):
                        conditions_met += 1
                        print(f"    Condition met: {condition}")  # Debug log
                    else:
                        print(f"    Condition NOT met: {condition}")  # Debug log
                except Exception as e:
                    print(f"    Error in condition check: {e}")  # Debug log

            result = (conditions_met / total_conditions) >= required_ratio
            print(
                f"  Entry conditions result at row {i}: {result} (Met {conditions_met}/{total_conditions})"
            )  # Debug log
            return result

        except Exception as e:
            print(f"Error in entry conditions at row {i}: {e}")  # Debug log
            return False

    # File: strategy_generator_ai.py
    # _evaluate_exit_conditions
    def _evaluate_exit_conditions(
        self,
        i: int,
        df: pd.DataFrame,
        indicators: Dict[str, pd.Series],
        exit_logic: Dict[str, Any],
    ) -> bool:
        try:
            print(f"  Evaluating exit conditions at row {i}")  # Debug log

            for condition in exit_logic.get("conditions", []):
                try:
                    if self._check_condition(i, df, indicators, condition):
                        print(f"    Exit Condition met: {condition}")  # Debug log
                        return True
                except Exception as e:
                    print(f"    Error in exit condition check: {e}")  # Debug log

            print(f"  Exit conditions NOT met at row {i}")  # Debug log
            return False

        except Exception as e:
            print(f"Error in exit conditions at row {i}: {e}")  # Debug log
            return False

    # File: strategy_generator_ai.py
    # _check_condition
    def _check_condition(
        self,
        i: int,
        df: pd.DataFrame,
        indicators: Dict[str, pd.Series],
        condition: Dict[str, Any],
    ) -> bool:
        try:
            indicator_name = condition["indicator"]
            operator = condition["operator"]
            threshold = condition["threshold"]

            if indicator_name not in indicators:
                print(f"    Indicator {indicator_name} not available")  # Debug log
                return False

            current_value = indicators[indicator_name].iloc[i]
            if pd.isna(current_value):
                print(f"    Indicator {indicator_name} NA at row {i}")  # Debug log
                return False

            # Log condition details
            print(
                f"    Checking condition: {indicator_name} {operator} {threshold} (Value: {current_value})"
            )  # Debug log

            # Evaluate the condition
            if operator == ">":
                return float(current_value) > float(threshold)
            elif operator == "<":
                return float(current_value) < float(threshold)
            elif operator == ">=":
                return float(current_value) >= float(threshold)
            elif operator == "<=":
                return float(current_value) <= float(threshold)
            elif operator == "between":
                return (
                    float(threshold[0]) <= float(current_value) <= float(threshold[1])
                )
            elif operator == "crossover":
                prev_value = indicators[indicator_name].iloc[i - 1] if i > 0 else None
                return prev_value is not None and float(prev_value) <= float(
                    threshold
                ) < float(current_value)
            elif operator == "crossunder":
                prev_value = indicators[indicator_name].iloc[i - 1] if i > 0 else None
                return prev_value is not None and float(prev_value) >= float(
                    threshold
                ) > float(current_value)

            print(f"    Unknown operator {operator}")  # Debug log
            return False

        except Exception as e:
            print(f"    Error checking condition: {condition} ({e})")  # Debug log
            return False

        except Exception:
            return False

    def _execute_trades(
        self, df: pd.DataFrame, signals: pd.Series
    ) -> Tuple[List[Dict[str, Any]], pd.Series]:
        """Execute trades based on signals - ENHANCED error handling"""
        trades: List[Dict[str, Any]] = []
        equity: List[float] = [10000.0]  # Starting capital
        position: Optional[str] = None
        entry_price: float = 0.0
        entry_date: Any = None

        try:
            position_size_config: Dict[str, Any] = self.config.get(
                "position_sizing", {"method": "fixed", "size": 0.1}
            )

            for i in range(1, len(df)):
                try:
                    current_equity = equity[-1]

                    # Ensure we have valid price data
                    if pd.isna(df["Close"].iloc[i]):
                        equity.append(current_equity)
                        continue

                    # Entry signal
                    if signals.iloc[i] == 1 and position is None:
                        entry_price = float(df["Close"].iloc[i])
                        entry_date = df.index[i]
                        position = "long"

                    # Exit signal
                    elif signals.iloc[i] == -1 and position is not None:
                        exit_price = float(df["Close"].iloc[i])
                        exit_date = df.index[i]

                        # Calculate trade result
                        pnl_pct = (exit_price - entry_price) / entry_price
                        position_size = self._calculate_position_size(
                            current_equity, position_size_config
                        )
                        pnl_dollars = current_equity * position_size * pnl_pct

                        # Record trade
                        trade: Dict[str, Any] = {
                            "entry_date": entry_date,
                            "exit_date": exit_date,
                            "entry_price": entry_price,
                            "exit_price": exit_price,
                            "pnl_pct": pnl_pct * 100,
                            "pnl_dollars": pnl_dollars,
                            "position_size": position_size,
                            "duration": (
                                (exit_date - entry_date).days
                                if hasattr(exit_date - entry_date, "days")
                                else 1
                            ),
                            "profit": pnl_dollars,
                        }
                        trades.append(trade)

                        # Update equity
                        new_equity = current_equity + pnl_dollars
                        equity.append(max(new_equity, 1000.0))  # Prevent bankruptcy
                        position = None
                    else:
                        equity.append(current_equity)

                except Exception:
                    # If there's an error processing this bar, just carry forward equity
                    equity.append(equity[-1] if equity else 10000.0)
                    continue

        except Exception as e:
            print(f"  Error executing trades: {e}")

        # Ensure equity curve has same length as df
        while len(equity) < len(df):
            equity.append(equity[-1] if equity else 10000.0)

        return trades, pd.Series(equity[: len(df)], index=df.index[: len(equity)])

    def _calculate_position_size(self, equity: float, config: Dict[str, Any]) -> float:
        """Calculate position size based on configuration"""
        try:
            method = config.get("method", "fixed")
            size = config.get("size", 5000)  # Fallback to $5000
            print(
                f"DEBUG: Calculating position size -> method='{method}', size={size}"
            )  # Debug print

            if method == "fixed":
                return float(size)
            elif method == "volatility_adjusted":
                base_size = float(config.get("base_size", 0.1))
                volatility_factor = max(
                    float(config.get("volatility_factor", 1.0)), 0.5
                )
                return base_size / volatility_factor
            else:
                return 0.1
        except Exception as e:
            print(f"ERROR: Failed calculating position size -> {e}")  # Debug error
            return 0.05  # Conservative fallback

    def _calculate_performance_metrics(self) -> Dict[str, Any]:
        """Calculate performance metrics for this strategy - ENHANCED"""
        if not self.trades or len(self.equity_curve) < 2:
            return {
                "total_trades": 0,
                "win_rate": 0.0,
                "total_return_pct": 0.0,
                "max_drawdown_pct": 0.0,
                "volatility_pct": 0.0,
                "avg_trade_pct": 0.0,
                "avg_duration_days": 0.0,
                "sharpe_ratio": 0.0,
            }

        try:
            total_trades = len(self.trades)
            winning_trades = sum(1 for t in self.trades if t.get("pnl_pct", 0) > 0)
            win_rate = winning_trades / total_trades if total_trades > 0 else 0.0

            start_equity = float(self.equity_curve.iloc[0])
            end_equity = float(self.equity_curve.iloc[-1])
            total_return = (
                (end_equity / start_equity - 1) * 100 if start_equity > 0 else 0.0
            )

            peak = self.equity_curve.expanding().max()
            drawdown = (self.equity_curve - peak) / peak
            max_drawdown = abs(drawdown.min()) * 100 if len(drawdown) > 0 else 0.0

            daily_returns = self.equity_curve.pct_change().dropna()
            if len(daily_returns) > 1:
                volatility = float(daily_returns.std()) * np.sqrt(252) * 100
                avg_return = float(daily_returns.mean()) * 252
                sharpe_ratio = (
                    avg_return / (volatility / 100) if volatility > 0 else 0.0
                )
            else:
                volatility = 0.0
                sharpe_ratio = 0.0

            return {
                "total_trades": total_trades,
                "win_rate": win_rate,
                "total_return_pct": total_return,
                "max_drawdown_pct": max_drawdown,
                "volatility_pct": volatility,
                "avg_trade_pct": (
                    float(np.mean([t.get("pnl_pct", 0.0) for t in self.trades]))
                    if self.trades
                    else 0.0
                ),
                "avg_duration_days": (
                    float(np.mean([t.get("duration", 0.0) for t in self.trades]))
                    if self.trades
                    else 0.0
                ),
                "sharpe_ratio": sharpe_ratio,
            }
        except Exception as e:
            print(f"  Error calculating metrics: {e}")
            return {
                "total_trades": len(self.trades),
                "win_rate": 0.0,
                "total_return_pct": 0.0,
                "max_drawdown_pct": 0.0,
                "volatility_pct": 0.0,
                "avg_trade_pct": 0.0,
                "avg_duration_days": 0.0,
                "sharpe_ratio": 0.0,
            }


class ObjectiveAwareStrategyGenerator:
    """
    The CORE AI BRAIN that generates completely different strategies based on objectives
    This is where the magic happens - same indicators, totally different logic!
    ENHANCED: Better error handling and data compatibility
    """

    def __init__(
        self,
        indicator_library: ComprehensiveIndicatorLibrary,
        objective_manager: ObjectiveManager,
    ) -> None:
        self.indicator_lib: ComprehensiveIndicatorLibrary = indicator_library
        self.objective_manager: ObjectiveManager = objective_manager
        self.strategy_templates: Dict[str, Dict[str, Any]] = (
            self._create_strategy_templates()
        )
        self.generated_strategies: Dict[str, TradingStrategy] = {}

        print(" Objective-Aware Strategy Generator AI initialized")
        print(
            f" Ready to generate infinite strategies from {len(self.indicator_lib.indicators_catalog)} indicators"
        )

    def _create_strategy_templates(self) -> Dict[str, Dict[str, Any]]:
        """Create strategy templates for different objectives"""
        return {
            "linear_equity": {
                "focus": "consistency",
                "preferred_indicators": [
                    "bb_position",
                    "rsi",
                    "market_efficiency",
                    "stochastic",
                ],
                "entry_style": "ultra_selective",
                "exit_style": "quick_profits",
                "risk_management": "tight",
            },
            "max_roi": {
                "focus": "returns",
                "preferred_indicators": [
                    "tsf",
                    "linreg_slope",
                    "bb_position",
                    "volume_profile",
                ],
                "entry_style": "trend_following",
                "exit_style": "let_winners_run",
                "risk_management": "wide",
            },
            "min_drawdown": {
                "focus": "preservation",
                "preferred_indicators": [
                    "bb_position",
                    "support_resistance",
                    "rsi",
                    "atr",
                ],
                "entry_style": "extremely_selective",
                "exit_style": "immediate_profits",
                "risk_management": "ultra_tight",
            },
            "high_winrate": {
                "focus": "accuracy",
                "preferred_indicators": [
                    "bb_position",
                    "rsi",
                    "stochastic",
                    "market_efficiency",
                ],
                "entry_style": "mean_reversion",
                "exit_style": "quick_profits",
                "risk_management": "moderate",
            },
            "sharpe_ratio": {
                "focus": "risk_adjusted",
                "preferred_indicators": [
                    "bb_position",
                    "atr",
                    "volatility_ratio",
                    "rsi",
                ],
                "entry_style": "volatility_aware",
                "exit_style": "risk_adjusted",
                "risk_management": "dynamic",
            },
        }

    def generate_strategy_for_objective(
        self, objective_name: str, complexity_level: str = "moderate"
    ) -> TradingStrategy:
        """
        Generate a completely new strategy tailored to the specific objective
        This is the CORE GENERATIVE FUNCTION!
        ENHANCED: Better fallback handling
        """
        print(f"\n Generating strategy for objective: {objective_name.upper()}")

        try:
            # Get objective and its preferences
            objective = self.objective_manager.get_objective(objective_name)
            objective_prefs = objective.get_strategy_preferences()
            template = self.strategy_templates.get(
                objective_name, self.strategy_templates["linear_equity"]
            )

            # Generate unique strategy ID
            strategy_id = f"{objective_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"

            # AI GENERATES THE STRATEGY LOGIC BASED ON OBJECTIVE
            strategy_config = self._generate_adaptive_logic(
                objective_prefs, template, complexity_level
            )

            # Create strategy object
            strategy = TradingStrategy(strategy_id, objective_name, strategy_config)

            print(
                f" Generated strategy '{strategy_id}' with {len(strategy_config['indicators'])} indicators"
            )
            print(
                f" Entry conditions: {len(strategy_config['entry_logic']['conditions'])}"
            )
            print(
                f" Exit conditions: {len(strategy_config['exit_logic']['conditions'])}"
            )

            return strategy

        except Exception as e:
            print(f"  Error generating strategy: {e}")
            # Return a simple fallback strategy
            return self._create_fallback_strategy(objective_name)

    def _create_fallback_strategy(self, objective_name: str) -> TradingStrategy:
        """Create a simple fallback strategy when generation fails"""
        strategy_id = f"fallback_{objective_name}_{datetime.now().strftime('%H%M%S')}"

        config: Dict[str, Any] = {
            "indicators": ["bb_position", "rsi"],
            "entry_logic": {
                "conditions": [
                    {
                        "indicator": "bb_position",
                        "operator": "<",
                        "threshold": 30,
                        "weight": 1,
                    },
                    {"indicator": "rsi", "operator": "<", "threshold": 40, "weight": 1},
                ],
                "confirmation_ratio": 0.5,  # Entry condition confirmation threshold
                "style": "simple",
            },
            "exit_logic": {
                "conditions": [
                    {
                        "indicator": "bb_position",
                        "operator": ">",
                        "threshold": 70,
                        "weight": 1,
                    }
                ],
                "style": "simple",
            },
            "position_sizing": {
                "method": "fixed",
                "size": 5000,  # Default fixed size
            },
            "objective_focus": "fallback",
            "indicator_params": {
                "bb_position": {"length": 20, "deviation": 2.0},
                "rsi": {"length": 14},
            },
        }

        # Debug print to confirm fallback strategy configuration
        print(
            f"DEBUG: Fallback strategy for {objective_name} -> position_sizing={config['position_sizing']}"
        )

        return TradingStrategy(strategy_id, objective_name, config)

    def _generate_adaptive_logic(
        self,
        objective_prefs: Dict[str, Any],
        template: Dict[str, Any],
        complexity_level: str,
    ) -> Dict[str, Any]:
        """
        THE CORE AI LOGIC GENERATOR
        Creates completely different trading logic based on objectives
        """

        # Select indicators based on objective preferences
        preferred_indicators = template["preferred_indicators"]

        # Add some randomness for variety while staying objective-focused
        available_indicators = list(self.indicator_lib.indicators_catalog.keys())
        additional_indicators = [
            ind for ind in available_indicators if ind not in preferred_indicators
        ]

        # Determine number of indicators based on complexity
        complexity_map = {"simple": 3, "moderate": 5, "complex": 7}
        total_indicators = complexity_map.get(complexity_level, 5)

        # Select final indicator set
        selected_indicators = preferred_indicators[: total_indicators // 2]
        if len(selected_indicators) < total_indicators:
            random.shuffle(additional_indicators)
            selected_indicators.extend(
                additional_indicators[: total_indicators - len(selected_indicators)]
            )

        # Generate entry logic based on objective
        entry_logic = self._generate_entry_logic(
            objective_prefs, template, selected_indicators
        )

        # Generate exit logic based on objective
        exit_logic = self._generate_exit_logic(
            objective_prefs, template, selected_indicators
        )

        # Generate position sizing based on objective
        position_sizing = self._generate_position_sizing(objective_prefs)

        return {
            "indicators": selected_indicators,
            "entry_logic": entry_logic,
            "exit_logic": exit_logic,
            "position_sizing": position_sizing,
            "objective_focus": template["focus"],
            "indicator_params": self._generate_indicator_params(selected_indicators),
        }

    def _generate_entry_logic(
        self,
        objective_prefs: Dict[str, Any],
        template: Dict[str, Any],
        indicators: List[str],
    ) -> Dict[str, Any]:
        """Generate entry conditions based on objective preferences"""

        conditions: List[Dict[str, Any]] = []
        entry_style: str = template["entry_style"]

        if entry_style == "ultra_selective":
            confirmation_ratio = 0.8
            if "bb_position" in indicators:
                conditions.append(
                    {
                        "indicator": "bb_position",
                        "operator": "<",
                        "threshold": 25,
                        "weight": 2,
                    }
                )
            if "rsi" in indicators:
                conditions.append(
                    {
                        "indicator": "rsi",
                        "operator": "<",
                        "threshold": 35,
                        "weight": 2,
                    }
                )
            if "market_efficiency" in indicators:
                conditions.append(
                    {
                        "indicator": "market_efficiency",
                        "operator": ">",
                        "threshold": 60,
                        "weight": 1,
                    }
                )

        elif entry_style == "trend_following":
            confirmation_ratio = 0.6
            if "tsf" in indicators:
                conditions.append(
                    {
                        "indicator": "tsf",
                        "operator": "crossover",
                        "threshold": 0,
                        "weight": 3,
                    }
                )
            if "linreg_slope" in indicators:
                conditions.append(
                    {
                        "indicator": "linreg_slope",
                        "operator": ">",
                        "threshold": 0.1,
                        "weight": 2,
                    }
                )
            if "volume_profile" in indicators:
                conditions.append(
                    {
                        "indicator": "volume_profile",
                        "operator": ">=",
                        "threshold": 1,
                        "weight": 1,
                    }
                )

        elif entry_style == "extremely_selective":
            confirmation_ratio = 0.9
            if "bb_position" in indicators:
                conditions.append(
                    {
                        "indicator": "bb_position",
                        "operator": "between",
                        "threshold": [20, 30],
                        "weight": 3,
                    }
                )
            if "support_resistance" in indicators:
                conditions.append(
                    {
                        "indicator": "support_resistance",
                        "operator": ">=",
                        "threshold": 1,
                        "weight": 2,
                    }
                )

        elif entry_style == "mean_reversion":
            confirmation_ratio = 0.7
            if "bb_position" in indicators:
                conditions.append(
                    {
                        "indicator": "bb_position",
                        "operator": "<",
                        "threshold": 20,
                        "weight": 2,
                    }
                )
            if "stochastic" in indicators:
                conditions.append(
                    {
                        "indicator": "stochastic",
                        "operator": "<",
                        "threshold": 25,
                        "weight": 2,
                    }
                )

        else:
            confirmation_ratio = 0.6
            if "volatility_ratio" in indicators:
                conditions.append(
                    {
                        "indicator": "volatility_ratio",
                        "operator": "<",
                        "threshold": 1.2,
                        "weight": 2,
                    }
                )

        self._add_supplementary_conditions(conditions, indicators, entry_style)

        if not conditions:
            conditions.append(
                {
                    "indicator": indicators[0] if indicators else "bb_position",
                    "operator": "<",
                    "threshold": 50,
                    "weight": 1,
                }
            )

        return {
            "conditions": conditions,
            "confirmation_ratio": confirmation_ratio,
            "style": entry_style,
        }

    def _generate_exit_logic(
        self,
        objective_prefs: Dict[str, Any],
        template: Dict[str, Any],
        indicators: List[str],
    ) -> Dict[str, Any]:
        """Generate exit conditions based on objective preferences"""

        conditions: List[Dict[str, Any]] = []
        exit_style: str = template["exit_style"]

        if exit_style == "quick_profits":
            if "bb_position" in indicators:
                conditions.append(
                    {
                        "indicator": "bb_position",
                        "operator": ">",
                        "threshold": 60,
                        "weight": 2,
                    }
                )

        elif exit_style == "let_winners_run":
            if "bb_position" in indicators:
                conditions.append(
                    {
                        "indicator": "bb_position",
                        "operator": ">",
                        "threshold": 80,
                        "weight": 2,
                    }
                )
            if "linreg_slope" in indicators:
                conditions.append(
                    {
                        "indicator": "linreg_slope",
                        "operator": "<",
                        "threshold": 0,
                        "weight": 1,
                    }
                )

        elif exit_style == "immediate_profits":
            if "bb_position" in indicators:
                conditions.append(
                    {
                        "indicator": "bb_position",
                        "operator": ">",
                        "threshold": 55,
                        "weight": 3,
                    }
                )

        if "rsi" in indicators:
            conditions.append(
                {
                    "indicator": "rsi",
                    "operator": ">",
                    "threshold": 70,
                    "weight": 1,
                }
            )

        if not conditions:
            indicator_to_use = indicators[0] if indicators else "bb_position"
            conditions.append(
                {
                    "indicator": indicator_to_use,
                    "operator": ">",
                    "threshold": 70,
                    "weight": 1,
                }
            )

        return {"conditions": conditions, "style": exit_style}

    def _add_supplementary_conditions(
        self, conditions: List[Dict[str, Any]], indicators: List[str], entry_style: str
    ) -> None:
        """Add additional conditions for unused indicators"""

        if "volume_profile" in indicators and not any(
            c["indicator"] == "volume_profile" for c in conditions
        ):
            conditions.append(
                {
                    "indicator": "volume_profile",
                    "operator": ">=",
                    "threshold": 1,
                    "weight": 1,
                }
            )

        if "market_efficiency" in indicators and not any(
            c["indicator"] == "market_efficiency" for c in conditions
        ):
            threshold = (
                60 if entry_style in ["ultra_selective", "extremely_selective"] else 40
            )
            conditions.append(
                {
                    "indicator": "market_efficiency",
                    "operator": ">",
                    "threshold": threshold,
                    "weight": 1,
                }
            )

    def _generate_position_sizing(
        self, objective_prefs: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Generate position sizing rules based on objective"""

        risk_tolerance = objective_prefs.get("risk_tolerance", "moderate")
        print(
            f"DEBUG: Generating position sizing for risk_tolerance='{risk_tolerance}'"
        )  # Debug print

        if risk_tolerance == "minimal":
            return {"method": "fixed", "size": 0.02}
        elif risk_tolerance == "low":
            return {"method": "fixed", "size": 0.05}
        elif risk_tolerance == "moderate":
            return {"method": "fixed", "size": 5000}  # Set default to $5000 explicitly
        elif risk_tolerance == "high":
            return {"method": "fixed", "size": 0.12}
        else:
            sizing = {
                "method": "volatility_adjusted",
                "base_size": 0.08,
                "volatility_factor": 1.0,
            }
            print(f"DEBUG: Fallback position sizing -> {sizing}")  # Debug print
            return sizing

    def _generate_indicator_params(self, indicators: List[str]) -> Dict[str, Any]:
        """Generate parameters for indicators based on strategy needs"""
        params: Dict[str, Any] = {}

        for indicator in indicators:
            if indicator in self.indicator_lib.indicators_catalog:
                default_params = self.indicator_lib.indicators_catalog[indicator][
                    "params"
                ]
                params[indicator] = default_params.copy()

        return params

    def generate_multiple_strategies(
        self, objective_name: str, count: int = 5
    ) -> List[TradingStrategy]:
        """Generate multiple different strategies for the same objective"""

        strategies: List[TradingStrategy] = []
        complexity_levels = ["simple", "moderate", "complex"]

        for i in range(count):
            complexity = complexity_levels[i % len(complexity_levels)]
            strategy = self.generate_strategy_for_objective(objective_name, complexity)
            strategy.strategy_id += f"_v{i+1}"
            strategies.append(strategy)

        return strategies

    def compare_strategies_on_data(
        self, strategies: List[TradingStrategy], df: pd.DataFrame
    ) -> pd.DataFrame:
        """Test multiple strategies on the same data and compare results"""

        results: List[Dict[str, Any]] = []

        for strategy in strategies:
            print(f" Testing strategy: {strategy.strategy_id}")

            try:
                # Execute strategy
                strategy.execute_on_data(df, self.indicator_lib)

                # Calculate fitness for its objective
                objective = self.objective_manager.get_objective(
                    strategy.objective_name
                )
                fitness = objective.calculate_fitness(
                    strategy.trades, strategy.equity_curve
                )
                strategy.fitness_score = fitness

                # Collect results
                metrics = strategy.performance_metrics
                results.append(
                    {
                        "Strategy ID": strategy.strategy_id,
                        "Objective": strategy.objective_name.replace("_", " ").title(),
                        "Fitness Score": f"{fitness:.3f}",
                        "Total Return %": f"{metrics.get('total_return_pct', 0):.1f}%",
                        "Max Drawdown %": f"{metrics.get('max_drawdown_pct', 0):.1f}%",
                        "Win Rate %": f"{metrics.get('win_rate', 0)*100:.1f}%",
                        "Total Trades": metrics.get("total_trades", 0),
                        "Avg Trade %": f"{metrics.get('avg_trade_pct', 0):.2f}%",
                        "Sharpe Ratio": f"{metrics.get('sharpe_ratio', 0):.2f}",
                    }
                )

            except Exception as e:
                print(f" Strategy {strategy.strategy_id} failed: {e}")
                results.append(
                    {
                        "Strategy ID": strategy.strategy_id,
                        "Objective": strategy.objective_name.replace("_", " ").title(),
                        "Fitness Score": "FAILED",
                        "Total Return %": "N/A",
                        "Max Drawdown %": "N/A",
                        "Win Rate %": "N/A",
                        "Total Trades": 0,
                        "Avg Trade %": "N/A",
                        "Sharpe Ratio": "N/A",
                    }
                )

        return pd.DataFrame(results)


def demonstrate_objective_aware_ai() -> None:
    """Demonstrate the AI generating different strategies for different objectives"""
    print("\n OBJECTIVE-AWARE AI DEMONSTRATION")
    print("=" * 60)

    try:
        # Initialize components
        indicator_lib = ComprehensiveIndicatorLibrary()
        objective_manager = ObjectiveManager()
        ai_generator = ObjectiveAwareStrategyGenerator(indicator_lib, objective_manager)

        # Generate strategies for different objectives
        objectives_to_test = [
            "linear_equity",
            "max_roi",
            "min_drawdown",
            "high_winrate",
        ]

        print(
            f"\n Generating strategies for {len(objectives_to_test)} different objectives:"
        )

        strategies = []
        for objective in objectives_to_test:
            try:
                strategy = ai_generator.generate_strategy_for_objective(objective)
                strategies.append(strategy)
                print(f" Generated {objective} strategy")
            except Exception as e:
                print(f"  Failed to generate {objective} strategy: {e}")

        # Show how different the strategies are
        print(f"\n STRATEGY COMPARISON - Same Indicators, Different Logic:")
        print("-" * 60)

        for strategy in strategies:
            config = strategy.config
            print(f"\n{strategy.objective_name.upper()} Strategy:")
            print(f"  Indicators: {', '.join(config['indicators'][:3])}...")
            print(f"  Entry conditions: {len(config['entry_logic']['conditions'])}")
            print(
                f"  Confirmation ratio: {config['entry_logic']['confirmation_ratio']:.1%}"
            )
            print(f"  Position size: {config['position_sizing']['size']:.1%}")
            print(f"  Focus: {config['objective_focus']}")

    except Exception as e:
        print(f" Demonstration failed: {e}")


if __name__ == "__main__":
    print(" OBJECTIVE-AWARE STRATEGY GENERATOR AI")
    print("=" * 60)
    print(" Generates completely different strategies based on your objectives!")
    print(" Same indicators → Infinite strategic possibilities")

    # Run demonstration
    demonstrate_objective_aware_ai()

    print(f"\n CORE AI BRAIN COMPLETE!")
    print(" Ready to generate adaptive strategies for any objective!")
    print("\nNext steps:")
    print("- Test on real market data")
    print("- Add strategy evolution/learning")
    print("- Connect to live trading system")
