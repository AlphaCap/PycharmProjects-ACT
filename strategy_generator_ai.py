"""
Objective-Aware Strategy Generator AI - FIXED for nGS data compatibility
The CORE BRAIN that generates completely different trading strategies based on objectives
Same indicators + Different objectives = Totally different trading logic!
FIXED: Better error handling and data format compatibility
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Tuple, Any
import random
from datetime import datetime
import warnings
warnings.filterwarnings('ignore')

# Import your previous components
from comprehensive_indicator_library import ComprehensiveIndicatorLibrary
from performance_objectives import ObjectiveManager, PerformanceObjective

class TradingStrategy:
    """
    Container for a complete trading strategy generated by AI
    Includes all logic for entries, exits, position sizing, and risk management
    ENHANCED: Better error handling and data compatibility
    """
    
    def __init__(self, strategy_id: str, objective_name: str, 
                 strategy_config: Dict, fitness_score: float = 0.0):
        self.strategy_id = strategy_id
        self.objective_name = objective_name
        self.config = strategy_config
        self.fitness_score = fitness_score
        self.trades = []
        self.equity_curve = pd.Series()
        self.performance_metrics = {}
        
    def execute_on_data(self, df: pd.DataFrame, indicator_lib: ComprehensiveIndicatorLibrary) -> Dict:
        """
        Execute this strategy on historical data - ENHANCED with error handling
        """
        try:
            print(f"üîç Executing strategy {self.strategy_id} on {len(df)} bars of data")
            
            # CRITICAL: Ensure data has minimum required length
            if len(df) < 50:
                print(f"‚ö†Ô∏è  Insufficient data: {len(df)} bars (need min 50)")
                return self._return_empty_results()
            
            # CRITICAL: Verify data columns
            if not self._validate_data_format(df):
                print(f"‚ö†Ô∏è  Invalid data format for strategy execution")
                return self._return_empty_results()
            
            # Calculate all required indicators with robust error handling
            indicators_needed = self.config['indicators']
            indicator_data = {}
            successful_indicators = []
            
            print(f"üìä Calculating {len(indicators_needed)} indicators...")
            
            for indicator_name in indicators_needed:
                try:
                    params = self.config.get('indicator_params', {}).get(indicator_name, {})
                    print(f"   Calculating {indicator_name}...")
                    
                    # FIXED: Use the enhanced indicator library that handles column standardization
                    indicator_values = indicator_lib.calculate_indicator(
                        indicator_name, df, **params
                    )
                    
                    # Validate indicator results
                    if indicator_values is not None and not indicator_values.empty:
                        valid_count = indicator_values.dropna().shape[0]
                        if valid_count > 10:  # Need at least some valid values
                            indicator_data[indicator_name] = indicator_values
                            successful_indicators.append(indicator_name)
                            print(f"   ‚úÖ {indicator_name}: {valid_count} valid values")
                        else:
                            print(f"   ‚ö†Ô∏è  {indicator_name}: Too few valid values ({valid_count})")
                    else:
                        print(f"   ‚ùå {indicator_name}: No data returned")
                        
                except Exception as e:
                    print(f"   ‚ùå {indicator_name}: Error - {str(e)[:60]}...")
                    continue
            
            if len(successful_indicators) < 2:
                print(f"‚ö†Ô∏è  Only {len(successful_indicators)} indicators successful - strategy needs more")
                return self._return_empty_results()
            
            print(f"‚úÖ Successfully calculated {len(successful_indicators)} indicators")
            
            # Update strategy config to only use successful indicators
            self.config['indicators'] = successful_indicators
            self._update_conditions_for_available_indicators(successful_indicators)
            
            # Generate trading signals
            print(f"üéØ Generating trading signals...")
            signals = self._generate_signals(df, indicator_data)
            signal_count = (signals != 0).sum()
            print(f"   Generated {signal_count} trading signals")
            
            # Execute trades based on signals
            print(f"üí∞ Executing trades...")
            trades, equity_curve = self._execute_trades(df, signals)
            print(f"   Completed {len(trades)} trades")
            
            # Store results
            self.trades = trades
            self.equity_curve = equity_curve
            self.performance_metrics = self._calculate_performance_metrics()
            
            print(f"‚úÖ Strategy execution complete")
            
            return {
                'trades': trades,
                'equity_curve': equity_curve,
                'metrics': self.performance_metrics,
                'signals': signals,
                'successful_indicators': successful_indicators
            }
            
        except Exception as e:
            print(f"‚ùå Strategy execution failed: {e}")
            import traceback
            traceback.print_exc()
            return self._return_empty_results()
    
    def _validate_data_format(self, df: pd.DataFrame) -> bool:
        """Validate that data has required columns"""
        required_cols = ['Close', 'High', 'Low', 'Open']  # After standardization
        
        # Check for various column name formats
        available_cols = df.columns.tolist()
        has_close = any(col.lower() in ['close', 'Close'] for col in available_cols)
        has_high = any(col.lower() in ['high', 'High'] for col in available_cols)
        has_low = any(col.lower() in ['low', 'Low'] for col in available_cols)
        has_open = any(col.lower() in ['open', 'Open'] for col in available_cols)
        
        if not (has_close and has_high and has_low and has_open):
            print(f"‚ùå Missing required columns. Available: {available_cols}")
            return False
        
        return True
    
    def _return_empty_results(self) -> Dict:
        """Return empty results when strategy execution fails"""
        return {
            'trades': [],
            'equity_curve': pd.Series([10000]),  # Starting capital
            'metrics': {},
            'signals': pd.Series([0]),
            'successful_indicators': []
        }
    
    def _update_conditions_for_available_indicators(self, available_indicators: List[str]):
        """Update entry/exit conditions to only use available indicators"""
        try:
            # Update entry logic
            entry_conditions = []
            for condition in self.config['entry_logic']['conditions']:
                if condition['indicator'] in available_indicators:
                    entry_conditions.append(condition)
            
            if entry_conditions:
                self.config['entry_logic']['conditions'] = entry_conditions
            else:
                # Fallback: create basic conditions with available indicators
                if 'bb_position' in available_indicators:
                    entry_conditions.append({
                        'indicator': 'bb_position',
                        'operator': '<',
                        'threshold': 30,
                        'weight': 1
                    })
                if 'rsi' in available_indicators:
                    entry_conditions.append({
                        'indicator': 'rsi',
                        'operator': '<',
                        'threshold': 40,
                        'weight': 1
                    })
                self.config['entry_logic']['conditions'] = entry_conditions
            
            # Update exit logic
            exit_conditions = []
            for condition in self.config['exit_logic']['conditions']:
                if condition['indicator'] in available_indicators:
                    exit_conditions.append(condition)
            
            if exit_conditions:
                self.config['exit_logic']['conditions'] = exit_conditions
            else:
                # Fallback: create basic exit conditions 
                if 'bb_position' in available_indicators:
                    exit_conditions.append({
                        'indicator': 'bb_position',
                        'operator': '>',
                        'threshold': 70,
                        'weight': 1
                    })
                self.config['exit_logic']['conditions'] = exit_conditions
                
        except Exception as e:
            print(f"‚ö†Ô∏è  Error updating conditions: {e}")
    
    def _generate_signals(self, df: pd.DataFrame, indicators: Dict) -> pd.Series:
        """Generate buy/sell signals based on strategy logic - ENHANCED error handling"""
        signals = pd.Series(0, index=df.index)  # 0=hold, 1=buy, -1=sell
        
        try:
            entry_logic = self.config['entry_logic']
            exit_logic = self.config['exit_logic']
            
            in_position = False
            
            for i in range(50, len(df)):  # Start after warmup period
                try:
                    if not in_position:
                        # Check entry conditions
                        if self._evaluate_entry_conditions(i, df, indicators, entry_logic):
                            signals.iloc[i] = 1
                            in_position = True
                    else:
                        # Check exit conditions (if in position)
                        if self._evaluate_exit_conditions(i, df, indicators, exit_logic):
                            signals.iloc[i] = -1
                            in_position = False
                except Exception as e:
                    # Skip this bar if there's an error
                    continue
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Error generating signals: {e}")
        
        return signals
    
    def _evaluate_entry_conditions(self, i: int, df: pd.DataFrame, 
                                 indicators: Dict, entry_logic: Dict) -> bool:
        """Evaluate if entry conditions are met - ENHANCED error handling"""
        try:
            conditions_met = 0
            total_conditions = len(entry_logic['conditions'])
            
            if total_conditions == 0:
                return False
            
            for condition in entry_logic['conditions']:
                try:
                    if self._check_condition(i, df, indicators, condition):
                        conditions_met += 1
                except:
                    continue  # Skip failed condition checks
            
            # Check if enough conditions are met
            required_ratio = entry_logic.get('confirmation_ratio', 0.6)
            return (conditions_met / total_conditions) >= required_ratio
            
        except Exception:
            return False
    
    def _evaluate_exit_conditions(self, i: int, df: pd.DataFrame, 
                                indicators: Dict, exit_logic: Dict) -> bool:
        """Evaluate if exit conditions are met - ENHANCED error handling"""
        try:
            if len(exit_logic['conditions']) == 0:
                return False
                
            for condition in exit_logic['conditions']:
                try:
                    if self._check_condition(i, df, indicators, condition):
                        return True
                except:
                    continue  # Skip failed condition checks
            return False
        except Exception:
            return False
    
    def _check_condition(self, i: int, df: pd.DataFrame, indicators: Dict, condition: Dict) -> bool:
        """Check individual condition - ENHANCED error handling"""
        try:
            indicator_name = condition['indicator']
            operator = condition['operator']
            threshold = condition['threshold']
            
            if indicator_name not in indicators:
                return False
            
            # Ensure we have enough data
            if i >= len(indicators[indicator_name]):
                return False
                
            current_value = indicators[indicator_name].iloc[i]
            
            if pd.isna(current_value):
                return False
            
            # Apply operator with better error handling
            if operator == '>':
                return float(current_value) > float(threshold)
            elif operator == '<':
                return float(current_value) < float(threshold)
            elif operator == '>=':
                return float(current_value) >= float(threshold)
            elif operator == '<=':
                return float(current_value) <= float(threshold)
            elif operator == 'between':
                if isinstance(threshold, (list, tuple)) and len(threshold) == 2:
                    return float(threshold[0]) <= float(current_value) <= float(threshold[1])
                return False
            elif operator == 'crossover':
                # Check if indicator crossed above threshold
                if i > 0 and i < len(indicators[indicator_name]):
                    prev_value = indicators[indicator_name].iloc[i-1]
                    if not pd.isna(prev_value):
                        return float(prev_value) <= float(threshold) < float(current_value)
                return False
            elif operator == 'crossunder':
                # Check if indicator crossed below threshold
                if i > 0 and i < len(indicators[indicator_name]):
                    prev_value = indicators[indicator_name].iloc[i-1]
                    if not pd.isna(prev_value):
                        return float(prev_value) >= float(threshold) > float(current_value)
                return False
            
            return False
            
        except Exception as e:
            return False
    
    def _execute_trades(self, df: pd.DataFrame, signals: pd.Series) -> Tuple[List[Dict], pd.Series]:
        """Execute trades based on signals - ENHANCED error handling"""
        trades = []
        equity = [10000]  # Starting capital
        position = None
        entry_price = 0
        entry_date = None
        
        try:
            position_size_config = self.config.get('position_sizing', {'method': 'fixed', 'size': 0.1})
            
            for i in range(1, len(df)):
                try:
                    current_equity = equity[-1]
                    
                    # Ensure we have valid price data
                    if pd.isna(df['Close'].iloc[i]):
                        equity.append(current_equity)
                        continue
                    
                    # Entry signal
                    if signals.iloc[i] == 1 and position is None:
                        entry_price = float(df['Close'].iloc[i])
                        entry_date = df.index[i]
                        position = 'long'
                        
                    # Exit signal
                    elif signals.iloc[i] == -1 and position is not None:
                        exit_price = float(df['Close'].iloc[i])
                        exit_date = df.index[i]
                        
                        # Calculate trade result
                        pnl_pct = (exit_price - entry_price) / entry_price
                        position_size = self._calculate_position_size(current_equity, position_size_config)
                        pnl_dollars = current_equity * position_size * pnl_pct
                        
                        # Record trade
                        trade = {
                            'entry_date': entry_date,
                            'exit_date': exit_date,
                            'entry_price': entry_price,
                            'exit_price': exit_price,
                            'pnl_pct': pnl_pct * 100,
                            'pnl_dollars': pnl_dollars,
                            'position_size': position_size,
                            'duration': (exit_date - entry_date).days if hasattr(exit_date - entry_date, 'days') else 1,
                            'profit': pnl_dollars  # Add for compatibility
                        }
                        trades.append(trade)
                        
                        # Update equity
                        new_equity = current_equity + pnl_dollars
                        equity.append(max(new_equity, 1000))  # Prevent bankruptcy
                        position = None
                    else:
                        equity.append(current_equity)
                        
                except Exception as e:
                    # If there's an error processing this bar, just carry forward equity
                    equity.append(equity[-1] if equity else 10000)
                    continue
        
        except Exception as e:
            print(f"‚ö†Ô∏è  Error executing trades: {e}")
        
        # Ensure equity curve has same length as df
        while len(equity) < len(df):
            equity.append(equity[-1] if equity else 10000)
            
        return trades, pd.Series(equity[:len(df)], index=df.index[:len(equity)])
    
    def _calculate_position_size(self, equity: float, config: Dict) -> float:
        """Calculate position size based on configuration - ENHANCED"""
        try:
            method = config.get('method', 'fixed')
            
            if method == 'fixed':
                return min(config.get('size', 0.1), 0.2)  # Cap at 20%
            elif method == 'volatility_adjusted':
                # Simple volatility adjustment
                base_size = config.get('base_size', 0.1)
                volatility_factor = max(config.get('volatility_factor', 1.0), 0.5)
                return min(base_size / volatility_factor, 0.2)
            else:
                return 0.1
        except:
            return 0.05  # Conservative fallback
    
    def _calculate_performance_metrics(self) -> Dict:
        """Calculate performance metrics for this strategy - ENHANCED"""
        if not self.trades or len(self.equity_curve) < 2:
            return {
                'total_trades': 0,
                'win_rate': 0,
                'total_return_pct': 0,
                'max_drawdown_pct': 0,
                'volatility_pct': 0,
                'avg_trade_pct': 0,
                'avg_duration_days': 0,
                'sharpe_ratio': 0
            }
        
        try:
            # Basic metrics
            total_trades = len(self.trades)
            winning_trades = sum(1 for t in self.trades if t['pnl_pct'] > 0)
            win_rate = winning_trades / total_trades if total_trades > 0 else 0
            
            # Return metrics
            start_equity = self.equity_curve.iloc[0]
            end_equity = self.equity_curve.iloc[-1]
            total_return = (end_equity / start_equity - 1) * 100 if start_equity > 0 else 0
            
            # Drawdown
            peak = self.equity_curve.expanding().max()
            drawdown = (self.equity_curve - peak) / peak
            max_drawdown = abs(drawdown.min()) * 100 if len(drawdown) > 0 else 0
            
            # Risk metrics
            daily_returns = self.equity_curve.pct_change().dropna()
            if len(daily_returns) > 1:
                volatility = daily_returns.std() * np.sqrt(252) * 100
                avg_return = daily_returns.mean() * 252
                sharpe_ratio = avg_return / (volatility / 100) if volatility > 0 else 0
            else:
                volatility = 0
                sharpe_ratio = 0
            
            return {
                'total_trades': total_trades,
                'win_rate': win_rate,
                'total_return_pct': total_return,
                'max_drawdown_pct': max_drawdown,
                'volatility_pct': volatility,
                'avg_trade_pct': np.mean([t['pnl_pct'] for t in self.trades]) if self.trades else 0,
                'avg_duration_days': np.mean([t['duration'] for t in self.trades]) if self.trades else 0,
                'sharpe_ratio': sharpe_ratio
            }
        except Exception as e:
            print(f"‚ö†Ô∏è  Error calculating metrics: {e}")
            return {
                'total_trades': len(self.trades),
                'win_rate': 0,
                'total_return_pct': 0,
                'max_drawdown_pct': 0,
                'volatility_pct': 0,
                'avg_trade_pct': 0,
                'avg_duration_days': 0,
                'sharpe_ratio': 0
            }

class ObjectiveAwareStrategyGenerator:
    """
    The CORE AI BRAIN that generates completely different strategies based on objectives
    This is where the magic happens - same indicators, totally different logic!
    ENHANCED: Better error handling and data compatibility
    """
    
    def __init__(self, indicator_library: ComprehensiveIndicatorLibrary,
                 objective_manager: ObjectiveManager):
        self.indicator_lib = indicator_library
        self.objective_manager = objective_manager
        self.strategy_templates = self._create_strategy_templates()
        self.generated_strategies = {}
        
        print("üß† Objective-Aware Strategy Generator AI initialized")
        print(f"üîß Ready to generate infinite strategies from {len(self.indicator_lib.indicators_catalog)} indicators")
    
    def _create_strategy_templates(self) -> Dict:
        """Create strategy templates for different objectives"""
        return {
            'linear_equity': {
                'focus': 'consistency',
                'preferred_indicators': ['bb_position', 'rsi', 'market_efficiency', 'stochastic'],
                'entry_style': 'ultra_selective',
                'exit_style': 'quick_profits',
                'risk_management': 'tight'
            },
            'max_roi': {
                'focus': 'returns',
                'preferred_indicators': ['tsf', 'linreg_slope', 'bb_position', 'volume_profile'],
                'entry_style': 'trend_following',
                'exit_style': 'let_winners_run',
                'risk_management': 'wide'
            },
            'min_drawdown': {
                'focus': 'preservation',
                'preferred_indicators': ['bb_position', 'support_resistance', 'rsi', 'atr'],
                'entry_style': 'extremely_selective',
                'exit_style': 'immediate_profits',
                'risk_management': 'ultra_tight'
            },
            'high_winrate': {
                'focus': 'accuracy',
                'preferred_indicators': ['bb_position', 'rsi', 'stochastic', 'market_efficiency'],
                'entry_style': 'mean_reversion',
                'exit_style': 'quick_profits',
                'risk_management': 'moderate'
            },
            'sharpe_ratio': {
                'focus': 'risk_adjusted',
                'preferred_indicators': ['bb_position', 'atr', 'volatility_ratio', 'rsi'],
                'entry_style': 'volatility_aware',
                'exit_style': 'risk_adjusted',
                'risk_management': 'dynamic'
            }
        }
    
    def generate_strategy_for_objective(self, objective_name: str, 
                                      complexity_level: str = 'moderate') -> TradingStrategy:
        """
        Generate a completely new strategy tailored to the specific objective
        This is the CORE GENERATIVE FUNCTION!
        ENHANCED: Better fallback handling
        """
        print(f"\nüéØ Generating strategy for objective: {objective_name.upper()}")
        
        try:
            # Get objective and its preferences
            objective = self.objective_manager.get_objective(objective_name)
            objective_prefs = objective.get_strategy_preferences()
            template = self.strategy_templates.get(objective_name, self.strategy_templates['linear_equity'])
            
            # Generate unique strategy ID
            strategy_id = f"{objective_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            
            # AI GENERATES THE STRATEGY LOGIC BASED ON OBJECTIVE
            strategy_config = self._generate_adaptive_logic(objective_prefs, template, complexity_level)
            
            # Create strategy object
            strategy = TradingStrategy(strategy_id, objective_name, strategy_config)
            
            print(f"‚úÖ Generated strategy '{strategy_id}' with {len(strategy_config['indicators'])} indicators")
            print(f"üìä Entry conditions: {len(strategy_config['entry_logic']['conditions'])}")
            print(f"üéØ Exit conditions: {len(strategy_config['exit_logic']['conditions'])}")
            
            return strategy
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Error generating strategy: {e}")
            # Return a simple fallback strategy
            return self._create_fallback_strategy(objective_name)
    
    def _create_fallback_strategy(self, objective_name: str) -> TradingStrategy:
        """Create a simple fallback strategy when generation fails"""
        strategy_id = f"fallback_{objective_name}_{datetime.now().strftime('%H%M%S')}"
        
        # Simple strategy using only basic indicators
        config = {
            'indicators': ['bb_position', 'rsi'],
            'entry_logic': {
                'conditions': [
                    {'indicator': 'bb_position', 'operator': '<', 'threshold': 30, 'weight': 1},
                    {'indicator': 'rsi', 'operator': '<', 'threshold': 40, 'weight': 1}
                ],
                'confirmation_ratio': 0.5,
                'style': 'simple'
            },
            'exit_logic': {
                'conditions': [
                    {'indicator': 'bb_position', 'operator': '>', 'threshold': 70, 'weight': 1}
                ],
                'style': 'simple'
            },
            'position_sizing': {'method': 'fixed', 'size': 0.05},
            'objective_focus': 'fallback',
            'indicator_params': {
                'bb_position': {'length': 20, 'deviation': 2.0},
                'rsi': {'length': 14}
            }
        }
        
        print(f"‚ö†Ô∏è  Using fallback strategy for {objective_name}")
        return TradingStrategy(strategy_id, objective_name, config)
    
    def _generate_adaptive_logic(self, objective_prefs: Dict, template: Dict, 
                               complexity_level: str) -> Dict:
        """
        THE CORE AI LOGIC GENERATOR
        Creates completely different trading logic based on objectives
        """
        
        # Select indicators based on objective preferences
        preferred_indicators = template['preferred_indicators']
        
        # Add some randomness for variety while staying objective-focused
        available_indicators = list(self.indicator_lib.indicators_catalog.keys())
        additional_indicators = [ind for ind in available_indicators 
                               if ind not in preferred_indicators]
        
        # Determine number of indicators based on complexity
        complexity_map = {'simple': 3, 'moderate': 5, 'complex': 7}
        total_indicators = complexity_map.get(complexity_level, 5)
        
        # Select final indicator set
        selected_indicators = preferred_indicators[:total_indicators//2]
        if len(selected_indicators) < total_indicators:
            random.shuffle(additional_indicators)
            selected_indicators.extend(additional_indicators[:total_indicators - len(selected_indicators)])
        
        # Generate entry logic based on objective
        entry_logic = self._generate_entry_logic(objective_prefs, template, selected_indicators)
        
        # Generate exit logic based on objective
        exit_logic = self._generate_exit_logic(objective_prefs, template, selected_indicators)
        
        # Generate position sizing based on objective
        position_sizing = self._generate_position_sizing(objective_prefs)
        
        return {
            'indicators': selected_indicators,
            'entry_logic': entry_logic,
            'exit_logic': exit_logic,
            'position_sizing': position_sizing,
            'objective_focus': template['focus'],
            'indicator_params': self._generate_indicator_params(selected_indicators)
        }
    
    def _generate_entry_logic(self, objective_prefs: Dict, template: Dict, 
                            indicators: List[str]) -> Dict:
        """Generate entry conditions based on objective preferences"""
        
        conditions = []
        entry_style = template['entry_style']
        
        # OBJECTIVE-SPECIFIC LOGIC GENERATION
        if entry_style == 'ultra_selective':
            # For linear equity - need MANY confirmations
            confirmation_ratio = 0.8  # 80% of conditions must be met
            
            # Mean-reversion focused entries
            if 'bb_position' in indicators:
                conditions.append({
                    'indicator': 'bb_position',
                    'operator': '<',
                    'threshold': 25,  # Oversold
                    'weight': 2  # High importance
                })
            
            if 'rsi' in indicators:
                conditions.append({
                    'indicator': 'rsi',
                    'operator': '<',
                    'threshold': 35,  # Oversold
                    'weight': 2
                })
            
            if 'market_efficiency' in indicators:
                conditions.append({
                    'indicator': 'market_efficiency',
                    'operator': '>',
                    'threshold': 60,  # Reasonable efficiency
                    'weight': 1
                })
        
        elif entry_style == 'trend_following':
            # For max ROI - trend-following entries
            confirmation_ratio = 0.6  # Only 60% need to agree (more opportunities)
            
            if 'tsf' in indicators:
                conditions.append({
                    'indicator': 'tsf',
                    'operator': 'crossover',
                    'threshold': 0,  # Price crossing above forecast
                    'weight': 3
                })
            
            if 'linreg_slope' in indicators:
                conditions.append({
                    'indicator': 'linreg_slope',
                    'operator': '>',
                    'threshold': 0.1,  # Positive trend
                    'weight': 2
                })
            
            if 'volume_profile' in indicators:
                conditions.append({
                    'indicator': 'volume_profile',
                    'operator': '>=',
                    'threshold': 1,  # High volume confirmation
                    'weight': 1
                })
        
        elif entry_style == 'extremely_selective':
            # For min drawdown - ultra-conservative
            confirmation_ratio = 0.9  # 90% must agree
            
            if 'bb_position' in indicators:
                conditions.append({
                    'indicator': 'bb_position',
                    'operator': 'between',
                    'threshold': [20, 30],  # Very specific range
                    'weight': 3
                })
            
            if 'support_resistance' in indicators:
                conditions.append({
                    'indicator': 'support_resistance',
                    'operator': '>=',
                    'threshold': 1,  # Near support
                    'weight': 2
                })
        
        elif entry_style == 'mean_reversion':
            # For high win rate - mean reversion focus
            confirmation_ratio = 0.7
            
            if 'bb_position' in indicators:
                conditions.append({
                    'indicator': 'bb_position',
                    'operator': '<',
                    'threshold': 20,  # Oversold
                    'weight': 2
                })
            
            if 'stochastic' in indicators:
                conditions.append({
                    'indicator': 'stochastic',
                    'operator': '<',
                    'threshold': 25,  # Oversold
                    'weight': 2
                })
        
        else:  # volatility_aware for Sharpe ratio
            confirmation_ratio = 0.6
            
            if 'volatility_ratio' in indicators:
                conditions.append({
                    'indicator': 'volatility_ratio',
                    'operator': '<',
                    'threshold': 1.2,  # Not too volatile
                    'weight': 2
                })
        
        # Add additional conditions for other indicators
        self._add_supplementary_conditions(conditions, indicators, entry_style)
        
        # Ensure we have at least one condition
        if not conditions:
            conditions.append({
                'indicator': indicators[0] if indicators else 'bb_position',
                'operator': '<',
                'threshold': 50,
                'weight': 1
            })
        
        return {
            'conditions': conditions,
            'confirmation_ratio': confirmation_ratio,
            'style': entry_style
        }
    
    def _generate_exit_logic(self, objective_prefs: Dict, template: Dict, 
                           indicators: List[str]) -> Dict:
        """Generate exit conditions based on objective preferences"""
        
        conditions = []
        exit_style = template['exit_style']
        
        # OBJECTIVE-SPECIFIC EXIT LOGIC
        if exit_style == 'quick_profits':
            # Take profits quickly for consistent growth
            if 'bb_position' in indicators:
                conditions.append({
                    'indicator': 'bb_position',
                    'operator': '>',
                    'threshold': 60,  # Take profit at 60% of BB range
                    'weight': 2
                })
        
        elif exit_style == 'let_winners_run':
            # Hold for bigger moves
            if 'bb_position' in indicators:
                conditions.append({
                    'indicator': 'bb_position',
                    'operator': '>',
                    'threshold': 80,  # Hold until near upper BB
                    'weight': 2
                })
            
            if 'linreg_slope' in indicators:
                conditions.append({
                    'indicator': 'linreg_slope',
                    'operator': '<',
                    'threshold': 0,  # Exit when trend turns
                    'weight': 1
                })
        
        elif exit_style == 'immediate_profits':
            # Ultra-fast profit taking for drawdown protection
            if 'bb_position' in indicators:
                conditions.append({
                    'indicator': 'bb_position',
                    'operator': '>',
                    'threshold': 55,  # Very quick profit taking
                    'weight': 3
                })
        
        # Always add RSI overbought exit if available
        if 'rsi' in indicators:
            conditions.append({
                'indicator': 'rsi',
                'operator': '>',
                'threshold': 70,  # Overbought exit
                'weight': 1
            })
        
        # Ensure we have at least one exit condition
        if not conditions:
            indicator_to_use = indicators[0] if indicators else 'bb_position'
            conditions.append({
                'indicator': indicator_to_use,
                'operator': '>',
                'threshold': 70,
                'weight': 1
            })
        
        return {
            'conditions': conditions,
            'style': exit_style
        }
    
    def _add_supplementary_conditions(self, conditions: List[Dict], 
                                    indicators: List[str], entry_style: str):
        """Add additional conditions for unused indicators"""
        
        # Add volume confirmation if available
        if 'volume_profile' in indicators and not any(c['indicator'] == 'volume_profile' for c in conditions):
            conditions.append({
                'indicator': 'volume_profile',
                'operator': '>=',
                'threshold': 1,
                'weight': 1
            })
        
        # Add efficiency filter if available
        if 'market_efficiency' in indicators and not any(c['indicator'] == 'market_efficiency' for c in conditions):
            threshold = 60 if entry_style in ['ultra_selective', 'extremely_selective'] else 40
            conditions.append({
                'indicator': 'market_efficiency',
                'operator': '>',
                'threshold': threshold,
                'weight': 1
            })
    
    def _generate_position_sizing(self, objective_prefs: Dict) -> Dict:
        """Generate position sizing rules based on objective"""
        
        risk_tolerance = objective_prefs.get('risk_tolerance', 'moderate')
        
        if risk_tolerance == 'minimal':
            return {'method': 'fixed', 'size': 0.02}  # 2% per trade
        elif risk_tolerance == 'low':
            return {'method': 'fixed', 'size': 0.05}  # 5% per trade
        elif risk_tolerance == 'moderate':
            return {'method': 'fixed', 'size': 0.08}  # 8% per trade
        elif risk_tolerance == 'high':
            return {'method': 'fixed', 'size': 0.12}  # 12% per trade
        else:
            return {'method': 'volatility_adjusted', 'base_size': 0.08, 'volatility_factor': 1.0}
    
    def _generate_indicator_params(self, indicators: List[str]) -> Dict:
        """Generate parameters for indicators based on strategy needs"""
        params = {}
        
        for indicator in indicators:
            if indicator in self.indicator_lib.indicators_catalog:
                default_params = self.indicator_lib.indicators_catalog[indicator]['params']
                # Could add parameter optimization here
                params[indicator] = default_params.copy()
        
        return params
    
    def generate_multiple_strategies(self, objective_name: str, 
                                   count: int = 5) -> List[TradingStrategy]:
        """Generate multiple different strategies for the same objective"""
        
        strategies = []
        complexity_levels = ['simple', 'moderate', 'complex']
        
        for i in range(count):
            complexity = complexity_levels[i % len(complexity_levels)]
            strategy = self.generate_strategy_for_objective(objective_name, complexity)
            strategy.strategy_id += f"_v{i+1}"
            strategies.append(strategy)
        
        return strategies
    
    def compare_strategies_on_data(self, strategies: List[TradingStrategy], 
                                 df: pd.DataFrame) -> pd.DataFrame:
        """Test multiple strategies on the same data and compare results"""
        
        results = []
        
        for strategy in strategies:
            print(f"üß™ Testing strategy: {strategy.strategy_id}")
            
            try:
                # Execute strategy
                strategy.execute_on_data(df, self.indicator_lib)
                
                # Calculate fitness for its objective
                objective = self.objective_manager.get_objective(strategy.objective_name)
                fitness = objective.calculate_fitness(strategy.trades, strategy.equity_curve)
                strategy.fitness_score = fitness
                
                # Collect results
                metrics = strategy.performance_metrics
                results.append({
                    'Strategy ID': strategy.strategy_id,
                    'Objective': strategy.objective_name.replace('_', ' ').title(),
                    'Fitness Score': f"{fitness:.3f}",
                    'Total Return %': f"{metrics.get('total_return_pct', 0):.1f}%",
                    'Max Drawdown %': f"{metrics.get('max_drawdown_pct', 0):.1f}%",
                    'Win Rate %': f"{metrics.get('win_rate', 0)*100:.1f}%",
                    'Total Trades': metrics.get('total_trades', 0),
                    'Avg Trade %': f"{metrics.get('avg_trade_pct', 0):.2f}%",
                    'Sharpe Ratio': f"{metrics.get('sharpe_ratio', 0):.2f}"
                })
                
            except Exception as e:
                print(f"‚ùå Strategy {strategy.strategy_id} failed: {e}")
                # Add failed result
                results.append({
                    'Strategy ID': strategy.strategy_id,
                    'Objective': strategy.objective_name.replace('_', ' ').title(),
                    'Fitness Score': "FAILED",
                    'Total Return %': "N/A",
                    'Max Drawdown %': "N/A", 
                    'Win Rate %': "N/A",
                    'Total Trades': 0,
                    'Avg Trade %': "N/A",
                    'Sharpe Ratio': "N/A"
                })
        
        return pd.DataFrame(results)

def demonstrate_objective_aware_ai():
    """Demonstrate the AI generating different strategies for different objectives"""
    print("\nüß† OBJECTIVE-AWARE AI DEMONSTRATION")
    print("=" * 60)
    
    try:
        # Initialize components
        indicator_lib = ComprehensiveIndicatorLibrary()
        objective_manager = ObjectiveManager()
        ai_generator = ObjectiveAwareStrategyGenerator(indicator_lib, objective_manager)
        
        # Generate strategies for different objectives
        objectives_to_test = ['linear_equity', 'max_roi', 'min_drawdown', 'high_winrate']
        
        print(f"\nüéØ Generating strategies for {len(objectives_to_test)} different objectives:")
        
        strategies = []
        for objective in objectives_to_test:
            try:
                strategy = ai_generator.generate_strategy_for_objective(objective)
                strategies.append(strategy)
                print(f"‚úÖ Generated {objective} strategy")
            except Exception as e:
                print(f"‚ö†Ô∏è  Failed to generate {objective} strategy: {e}")
        
        # Show how different the strategies are
        print(f"\nüìä STRATEGY COMPARISON - Same Indicators, Different Logic:")
        print("-" * 60)
        
        for strategy in strategies:
            config = strategy.config
            print(f"\n{strategy.objective_name.upper()} Strategy:")
            print(f"  Indicators: {', '.join(config['indicators'][:3])}...")
            print(f"  Entry conditions: {len(config['entry_logic']['conditions'])}")
            print(f"  Confirmation ratio: {config['entry_logic']['confirmation_ratio']:.1%}")
            print(f"  Position size: {config['position_sizing']['size']:.1%}")
            print(f"  Focus: {config['objective_focus']}")
    
    except Exception as e:
        print(f"‚ùå Demonstration failed: {e}")

if __name__ == "__main__":
    print("üß† OBJECTIVE-AWARE STRATEGY GENERATOR AI")
    print("=" * 60)
    print("üéØ Generates completely different strategies based on your objectives!")
    print("üìä Same indicators ‚Üí Infinite strategic possibilities")
    
    # Run demonstration
    demonstrate_objective_aware_ai()
    
    print(f"\n‚úÖ CORE AI BRAIN COMPLETE!")
    print("üöÄ Ready to generate adaptive strategies for any objective!")
    print("\nNext steps:")
    print("- Test on real market data")
    print("- Add strategy evolution/learning")
    print("- Connect to live trading system")